<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Red+Hat+Text:ital,wght@0,300..700;1,300..700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Red+Hat+Mono:ital,wght@0,300..700;1,300..700&family=Red+Hat+Text:ital,wght@0,300..700;1,300..700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <title>Robotics - Week 3</title>
</head>
<body>
    <div class="left-panel">
        <div class="left-block-panel">
            <div class="main-title"><a href="index.html" style="text-decoration: none; color: white;">Introduction to the <br>Robot Operating System 2</a></div>
            <div class="distro-title">Humble Hawksbill</div>
            <div class="mobile-support-flag">Hi! We're glad that you are eager to learn but we currently don't have support for devices with small viewports. The modules contain large images and codeblocks that can only be supported in desktop. We hope to add support for smaller viewports soon!</div>
        </div>
        
        <div class="left-block-panel">
            <div class="author-name">John Louis D. Lagramada</div>
            <div class="author-email"><a href="mailto:johnlouis.dante@gmail.com">johnlouis.dante@gmail.com</a></div>
        </div>
        <hr class="left-panel-divider">
        <div class="left-block-panel">
            <div class="course"><a href="week0.html"><span class="course-week-no">Week 0 </span>Gearing Up</a></div>
            <div class="course"><a href="week1.html"><span class="course-week-no">Week 1 </span>Introduction to ROS 2</a></div>
            <div class="course"><a href="week2.html"><span class="course-week-no">Week 2 </span>Object-Oriented Programming</a></div>
            <div class="course"><a href="week3.html"><span class="course-week-no">Week 3 </span>Nodes, Messages, and Topics</a></div>
            <div class="course"><a href="week4.html"><span class="course-week-no">Week 4 </span>Parameters</a></div>
            <div class="course"><a href="week5.html"><span class="course-week-no">Week 5 </span>Custom Launch</a></div>
            <div class="course"><a href="week6.html"><span class="course-week-no">Week 6 </span>Common ROS 2 Packages</a></div>
            <div class="course"><a href="week7.html"><span class="course-week-no">Week 7 </span>Services</a></div>
            <div class="course"><a href="week8.html"><span class="course-week-no">Week 8 </span>Actions</a></div>
        </div>
        <hr class="left-panel-divider">
        <div class="left-block-panel">
            <div class="final-project"><a href="final_proj.html" style="text-decoration: none; color:white;">Final Project</a></div>
            <div class="final-project-gallery">Gallery of Final Projects</div>
        </div>
        <hr class="left-panel-divider">
        <div class="left-block-panel">
            <div class="references">References</div>
            <div class="license">Licenses</div>
        </div>
    </div>
    <div class="right-panel">
        <div class="right-block-panel">
            <div class="content-header">
                <div class="content-title">Nodes, Messages, and Topics</div>
                <div class="content-author">Written by: Kyle Mhiron Bumagat and John Louis D. Lagramada</div>
                <hr class="content-divider">
                <div class="content-intro">This section discusses nodes and how they communicate using a publisher-subscriber architecture through topics using messages.</div>
            </div>
            <div class="content-content">
                <div class="content-h2">Objectives</div>
                <div class="content-division">
                    <ul>
                        <li>Learners will be able to define nodes, messages, and topics.</li>
                        <li>Learners will understand the publisher-subscriber architecture of ROS 2.</li>
                        <li>Learners will be able to demonstrate building nodes with built-in messages in line with developer standards.</li>
                        <li>Learners will be able to demonstrate how to encode and decode custom messages using serialization methods.</li>
                    </ul>
                </div>
            </div>
            <div class="content-content">
                <div class="content-h2">Concepts</div>
                <div class="content-division">
                    <div class="content-division-title">Nodes</div>
                    <div class="content-division-content">Each node in ROS should be responsible for a single, modular task. It is a fundamental building block of a robotic system. It represents a single process that performs computations, such as reading sensor data, controlling motors, or processing images. Each node can send and receive data from other nodes via topics, services, actions, or parameters. They communicate with each other to build a modular and scalable robotic system.</div>
                    <div class="content-division-content">Each node has a unique name in the ROS 2 system. They can be assigned specific names to prevent conflicts. The namespaces allow grouping of related nodes for better organization. The nodes can also be remapped dynamically at runtime.</div>
                    <div class="content-division-content">ROS 2 provides commands to list and monitor active nodes.</div>
                    <div class="content-division-content"><pre><code class="language-bash">ros2 node list</code></pre></div>
                    <div class="content-division-content">To get information about a specific node. You can use:</div>
                    <div class="content-division-content"><pre><code class="language-bash">ros2 node info /my_node</code></pre></div>
                    <div class="content-division-content">This displays details such as publishers, subscribers, services, and parameters associated with the node.</div>
                </div>
                <div class="content-division">
                    <div class="content-division-title">Messages</div>
                    <div class="content-division-content">Nodes communicate with each other by publishing messages to topics. A message is a simple data structure, comprising typed fields. They define the format of data that can be sent and received over topics, services, or actions. Each message consists of one or more fields, which can be basic types such as integers, floats, and strings or complex types like arrays and nested messages.</div>
                    <div class="content-division-content">ROS 2 nodes use messages to communicate via topics, services, and actions. In topics, it is often called the publisher-to-subscriber model. It is used for continuous data streaming. For example, the camera node publishes image messages, and a processing node subscribes to them.  In services, this is called the request-response model. It is used for on-demand communication. For example, a node requests sensor calibration data from another node. For the actions, a goal-feedback-result model is commonly used for long-duration tasks with feedback. For example, a robot arm moves to a target position and provides feedback on its status.</div>
                    <div class="content-division-content">For custom message types, users can create their own messages if predefined ones don’t meet their needs. Custom messages in ROS 2 are defined in .msg files, which specify data types like int32, float64, string.</div>
                    <div class="content-division-content">
                        <table>
                            <tr>
                              <th>Message Type</th>
                              <th>Description</th>
                              <th>Example</th>
                            </tr>
                            <tr>
                              <td>std_msgs/String</td>
                              <td>Sends text data</td>
                              <td>‘Hello!’</td>
                            </tr>
                            <tr>
                              <td>std_msgs/Int32</td>
                              <td>Sends an integer value</td>
                              <td>42</td>
                            </tr>
                            <tr>
                              <td>std_msgs/Float32</td>
                              <td>Send a floating point number</td>
                              <td>3.14</td>
                            </tr>
                            <tr>
                              <td>std_msgs/Bool</td>
                              <td>Sends a boolean value</td>
                              <td>True</td>
                            </tr>
                          </table>
                    </div>
                </div>
                <div class="content-division">
                    <div class="content-division-title">Topics</div>
                    <div class="content-division-content">In ROS 2, topics are the primary mechanism for message-based communication between nodes. A topic is a named channel where nodes exchange data using the publisher-subscriber model. In general, nodes are not aware of who they are communicating with. Instead, nodes that are interested in data subscribe to the relevant topic; nodes that generate data publish to the relevant topic. With that, multiple publishers and subscribers can use the same topic.</div>
                    <div class="content-division-content">Topics are intended for unidirectional, streaming communication. They do not need to establish direct connections; they just publish or subscribe to a topic name.</div>
                    <div class="content-division-content">Topics work in ROS 2 by a publisher node being created and assigned to a topic. Then, a subscriber node subscribes to the same topic. The publisher sends messages of a specific message type on the topic. The subscriber receives messages whenever new data is published on that topic.</div>
                    <div class="content-division-content">
                        <table>
                            <tr>
                              <th>Command</th>
                              <th>Description</th>
                            </tr>
                            <tr>
                              <td><code>ros2 topic list</code></td>
                              <td>List all active topics ros2 topic list</td>
                            </tr>
                            <tr>
                              <td><code>ros2 topic info /chatter</code></td>
                              <td>Get information about a specific topic</td>
                            </tr>
                            <tr>
                              <td><code>ros2 topic echo /chatter</code></td>
                              <td>View real-time messages published on a topic</td>
                            </tr>
                            <tr>
                              <td><code>ros2 topic type /chatter</code></td>
                              <td>Check message type of a topic</td>
                            </tr>
                          </table>                          
                    </div>
                </div>
            </div>
            <div class="content-content">
                <div class="content-h2">Programming</div>
                <div class="content-division">
                    <div class="content-division-title">Creating Subscriber and Publisher Nodes</div>
                    <div class="content-division-content">
                        <ol>
                            <li>Open your terminal.</li>
                            <li>Create a ROS 2 workspace and navigate into it.
                                <pre><code class="language-bash">cd ~/ros2_ws/src
ros2 pkg create --build-type ament_python ros2_learning
cd ros2_learning</code></pre>
                            </li>
                            <li>Edit setup.py to include the nodes. Change the maintainer name and maintainer email for submission.
                                <pre><code class="language-python">from setuptools import setup
package_name = 'ros2_learning'
setup(
    name=package_name,
    version='0.0.1',
    packages=[package_name],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='your_name',
    maintainer_email='your_email@example.com',
    description='A complete ROS 2 package for learning publisher-subscriber and serialization',
    license='Apache License 2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'talker = ros2_learning.talker:main',
            'listener = ros2_learning.listener:main',
        ],
    },
)</code></pre>
                            </li>
                            <li>Create the publisher node, talker.py.
                                <pre><code class="language-python">import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class Talker(Node):
    def __init__(self):
        super().__init__('talker')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        self.timer = self.create_timer(1.0, self.publish_message)
        self.count = 0

    def publish_message(self):
        msg = String()
        msg.data = f'Hello, ROS 2! Message {self.count}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: {msg.data}')
        self.count += 1

def main(args=None):
    rclpy.init(args=args)
    node = Talker()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()</code></pre>
                            </li>
                            <li>Create the subscriber node, listener.py.
                                <pre><code class="language-python">import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import pickle  # Import pickle for serialization

class Listener(Node):
    def __init__(self):
        super().__init__('listener')
        self.subscription = self.create_subscription(String, 'chatter', self.callback, 10)

    def callback(self, msg):
        serialized = pickle.dumps(msg.data)  # Convert message to bytes
        deserialized = pickle.loads(serialized)  # Decode message back to string

        self.get_logger().info(f'Received: {msg.data}')
        self.get_logger().info(f'Serialized: {serialized}')  # Print raw serialized data
        self.get_logger().info(f'Deserialized: {deserialized}')  # Print decoded message

def main(args=None):
    rclpy.init(args=args)
    node = Listener()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()</code></pre>
                            </li>
                            <li>Build the package and run it.
                                <pre><code class="language-python">cd ~/ros2_ws
colcon build --packages-select ros2_learning
source install/setup.bash</code></pre>
                            </li>
                            <li>Run the talker node in a new terminal.
                                <pre><code class="language-bash">ros2 run ros2_learning talker</code></pre>
                                The result should like the image below.
                                <img src="img/asset_32.png" alt="" class="screenshot">
                            </li>
                            <li>Run the listener node in a separate terminal.
                                <pre><code class="language-bash">ros2 run ros2_learning listener</code></pre>
                                The result should like the image below.
                                <img src="img/asset_31.png" alt="" class="screenshot">
                            </li>
                        </ol>
                    </div>
                </div>
                <div class="content-division">
                    <div class="content-division-title">Creating a Custom Message</div>
                    <div class="content-division-content">
                        <ol>
                            <li>Create a separate package under your workspace for the custom messages.
                                <pre><code class="language-bash">ros2 pkg create --build-type ament_cmake my_custom_msgs</code></pre>
                                You can see that we used <code class="inline-code-normal">ament_cmake</code> as our build type here. This is because you cannot create custom interfaces like messages with a Python package.
                            </li>
                            <li>Create a msg directory where messages will be stored.
                                <pre><code class="language-bash">cd my_custom_msgs && mkdir msg && cd msg</code></pre>
                            </li>
                            <li>You can now create a custom message.
                                <pre><code class="language-bash">code SensorData.msg</code></pre>
                                Visual Studio Code should open if it is properly installed. Write this in your file.
                                <pre><code class="language-cpp">float32 temperature
float32 pressure
string status</code></pre>
                            </li>
                            <li>We should now modify CMakeLists.txt.
                                The <code class="inline-code-normal">rosidl_default_generators</code> dependency is mandatory because it is responsible for creating the custom message.
                                <pre><code class="language-text">cmake_minimum_required(VERSION 3.8)
project(my_custom_msgs)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rosidl_default_generators REQUIRED)
find_package(std_msgs REQUIRED)  # Ensure std_msgs is found

# Generate custom messages
rosidl_generate_interfaces(${PROJECT_NAME}
    "msg/SensorData.msg"
    DEPENDENCIES std_msgs
)

# Export dependencies for other packages to use
ament_export_dependencies(rosidl_default_runtime)

if(BUILD_TESTING)
    find_package(ament_lint_auto REQUIRED)
    set(ament_cmake_copyright_FOUND TRUE)
    set(ament_cmake_cpplint_FOUND TRUE)
    ament_lint_auto_find_test_dependencies()
endif()

ament_package()
                                </code></pre>
                            </li>
                            <li>Modify the package.xml.
                                The dependencies are the same for this file.
                                <pre><code class="language-xml">&lt;?xml version="1.0"?&gt;
&lt;?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?&gt;
&lt;package format="3"&gt;
    &lt;name&gt;my_custom_msgs&lt;/name&gt;
    &lt;version&gt;0.0.0&lt;/version&gt;
    &lt;description&gt;Custom message definitions for ROS 2&lt;/description&gt;
    &lt;maintainer email="mhiky@todo.todo"&gt;mhiky&lt;/maintainer&gt;
    &lt;license&gt;Apache-2.0&lt;/license&gt;

    &lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;

    &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;

    &lt;depend&gt;rosidl_default_generators&lt;/depend&gt;
    &lt;depend&gt;builtin_interfaces&lt;/depend&gt;
    &lt;depend&gt;std_msgs&lt;/depend&gt;

    &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt;
    &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt;

    &lt;export&gt;
    &lt;build_type&gt;ament_cmake&lt;/build_type&gt;
    &lt;/export&gt;
&lt;/package&gt;</code></pre>
                            </li>
                            <li>Build the package and source the setup file.
                                <pre><code class="language-bash">cd ~/ros2_ws
colcon build --packages-select my_custom_msgs

source install/setup.bash</code></pre>
                            </li>
                            <li>We can now create a new publisher using our new custom message.
                                Create new ROS 2 package.
                                <pre><code class="language-bash">ros2 pkg create --build-type ament_python my_custom_pub</code></pre>
                                Inside my_custom_pub, modify setup.py to include the message package.
                                <pre><code class="language-python">entry_points={
    'console_scripts': [
        'sensor_publisher = my_custom_pub.sensor_publisher:main',
    ],
},
                                </code></pre>
                            </li>
                            <li>Create a Python publisher script inside ros2_ws/src/my_cutom_pub/my_custom_pub, name it as sensor_publisher.py
                                <pre><code class="language-python">import rclpy
from rclpy.node import Node
from my_custom_msgs.msg import SensorData
import random

class SensorPublisher(Node):
    def __init__(self):
        super().__init__('sensor_publisher')
        self.publisher_ = self.create_publisher(SensorData, 'sensor_topic', 10)
        self.timer = self.create_timer(1.0, self.publish_sensor_data)

    def publish_sensor_data(self):
        msg = SensorData()
        msg.temperature = random.uniform(20.0, 30.0)
        msg.pressure = random.uniform(1000, 1020)
        msg.status = "OK"
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: {msg.temperature}, {msg.pressure}, {msg.status}')

def main(args=None):
    rclpy.init(args=args)
    node = SensorPublisher()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()</code></pre>
                                Make it an executable file to successfully run it.
                                <pre><code class="language-bash">chmod +x ~/ros2_ws/src/my_custom_pub/my_custom_pub/sensor_publisher.py</code></pre>
                            </li>
                            <li>
                                Build the new package you created.
                                <pre><code class="language-bash">cd ~/ros2_ws
colcon build --packages-select my_custom_pub
source install/setup.bash</code></pre>
                            </li>
                            <li>Run the publisher in a new terminal.
                                <pre><code class="language-bash">source install/setup.bash
ros2 run my_custom_pub sensor_publisher
                                </code></pre>
                                The terminal should look like the image below.
                                <img src="img/asset_33.png" alt="" class="screenshot">
                            </li>
                        </ol>
                    </div>
                </div>
            </div>
            <div class="content-content">
                <div class="content-h2">Deeper Look at Nabi</div>
                <div class="content-division">
                    <div class="content-division-title">Content Title 1</div>
                    <div class="content-division-content">
                    Content 1
                    </div>
                </div>
            </div>
            <div class="content-content">
                <div class="content-h2">Assignment</div>
                <div class="content-division">
                    <div class="content-division-title">Content Title 1</div>
                    <div class="content-division-content">
                    <ol>
                        <li>Create a custom message named CustomMsg.msg that includes:
                            <ol>
                                <li>string</li>
                                <li>int32</li>
                                <li>float32</li>
                            </ol>
                        </li>
                        <li>Create a publisher node to send these messages.</li>
                        <li>Create a subscriber node to receive and process these messages.</li>
                    </ol>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>